#!/usr/bin/env python3
import sys
import os
import cryptocode
import random
import string
import getpass
from enum import Enum

help_msg = '''
  pswm <alias> <password>    - Stores a new password in the password vault.
  pswm <alias> -g [length]   - Generates a random password and stores it.
  pswm <alias> -d            - Deletes a password for a given alias.
  pswm <alias>               - Prints a password associated to an alias.
  pswm -a                    - Prints all stored passwords.
'''
min_length = 4
default_length = 16
max_length = 32

pass_vault_file = os.path.expanduser("~") + "/.pswm"


# Manager function for the master password. Asks the user for the master 
# password if there is already a password vault. If not, it creates a new
# password vault associated to a new master password. Can also reset the
# master password after 3 failed attempts.
# returns:
#    crypt_key: The master password.
#    lines: A list of lines containing the aliases and passwords decrypted 
#           from the password vault with the master password.
def manage_master_password():

    if not os.path.isfile(pass_vault_file):

        crypt_key = ""

        while len(crypt_key) < min_length or len(crypt_key) > max_length:
            crypt_key = getpass.getpass("[pswm] Create a master password (" +
                                        str(min_length) + "-" +
                                        str(max_length) +
                                        " chars): ")

        crypt_key_verify = ""
        while crypt_key_verify != crypt_key:
            crypt_key_verify = getpass.getpass("[pswm] Confirm your "
                                               "master password: ")

        lines = []
        lines.append("pswm\t" + crypt_key)
        return crypt_key, lines

    for i in range(3):
        crypt_key = getpass.getpass("[pswm] Master password: ")
        lines = encrypted_file_to_lines(pass_vault_file, crypt_key)

        if lines == False:
            print("Sorry, try again.")
        else:
            return crypt_key, lines

        if i == 2:
            print("\nYou have failed to enter the correct "
                  "master password 3 times.")
            return reset_master_password()


# Function to reset the master password.
# returns:
#   manage_master_password(): The result of manage_master_password() containing
#                            the new master password or False, "" if the user
#                            does not want to reset the master password.
def reset_master_password():
    print("Resetting your master password will delete your password vault.")
    text = input("[pswm] Do you want to reset your master password? (y/n): ")

    if text == "y":
        if os.path.isfile(pass_vault_file):
            os.remove(pass_vault_file)
        return manage_master_password()
    else:
        print("Password reset aborted.")
        return False, ""


# Splits each line of a list of lines into two parts. Then inserts the second
# part into the dictionary indexed by the first part.
# args:
#   lines: A list of lines.
# returns:
#   pass_vault: A dictionary containing the alias and password.
def lines_to_pass_vault(lines):

    pass_vault = {}

    for line in lines:
        line = line.rstrip()
        try:
            key, value = line.split('\t')
            pass_vault[key] = value
        except ValueError:
            pass

    return pass_vault


# For each key in the dictionary, it inserts a string into a list containing
# the key and the value separated by a tab.
# args:
#   pass_vault: A dictionary aliases and passwords.
# returns:
#   lines: A list of lines each formatted as key\tvalue.
def pass_vault_to_lines(pass_vault):

    lines = []
    for alias in pass_vault:
        lines.append(alias + '\t' + pass_vault[alias])

    return lines


# This function opens and decrypts the password vault.
# args:
#   file_name: The name of the file containing the password vault.
#   master_password: The master password to use to decrypt the password vault.
# returns:
#   decrypted_lines: A list of lines containing the decrypted aliases passwords.
def encrypted_file_to_lines(file_name, master_password):

    if not os.path.isfile(file_name):
        return ""

    decrypted_lines = []

    with open(file_name, 'r') as f:
        for line in f:
            decrypted_line = cryptocode.decrypt(line, master_password)

            if decrypted_line == False:
                return False

            decrypted_lines.append(decrypted_line)

    return decrypted_lines


# This function encrypts and stores the password vault.
# args:
#    lines: A list of lines containing the aliases and passwords.
#    file_name: The name of the file to store the password vault.
#    master_password: The master password to use to encrypt the password vault.
def lines_to_encrypted_file(lines, file_name, master_password):

    with open(file_name, 'w') as f:
        for line in lines:
            encrypted_line = cryptocode.encrypt(line, master_password)
            f.write(encrypted_line + "\n")


# This function generates a password of legth passed as argument.
# args:
#   length: The length of the random password to be generated.
# returns:
#   password: A string containing the random password.
def generate_password(length):
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(random.choice(characters) for i in range(int(length)))
    return password


# Enum for the different actions that can be performed by the password manager
class Command(Enum):
    ADD_KEY = 1
    GEN_DEF = 2
    GEN_LEN = 3
    DEL_KEY = 4
    GET_KEY = 5
    LST_KEY = 6
    DEFAULT = 7


# This function parses the command line arguments and returns a Command enum
# containing the action to be performed.
# returns:
#   command: The action to be performed
def parse_command():
    command = Command.DEFAULT

    for i in range(len(sys.argv)):
        if sys.argv[i].startswith("-") \
                and sys.argv[i] not in ["-a", "-d", "-g"]:
            print("Unknown option: " + sys.argv[i])
            return Command.DEFAULT
        if i == 1:
            if sys.argv[i] == "-a":
                command = Command.LST_KEY
            else:
                command = Command.GET_KEY
        elif i == 2:
            if sys.argv[i] == "-d":
                command = Command.DEL_KEY
            elif sys.argv[i] == "-g":
                command = Command.GEN_DEF
            else:
                command = Command.ADD_KEY
        elif i == 3:
            if sys.argv[i-1] == "-g":
                command = Command.GEN_LEN
        elif i > 3:
            print("Too many arguments.")
            return Command.DEFAULT
    return command


# Definition of the main function
def main():

    crypt_key, lines = manage_master_password()
    if crypt_key == False:
        return
    pass_vault = lines_to_pass_vault(lines)
    command = parse_command()

    if command == Command.ADD_KEY:  # pswm <alias> <password>

        if sys.argv[1] == "pswm":
            print("You cannot change or delete the master password.")       
        else:
            pass_vault[sys.argv[1]] = sys.argv[2]

    elif command == Command.GEN_DEF:  # pswm <alias> -g

        if sys.argv[1] == "pswm":
            print("You cannot change or delete the master password.")     
        else:
            password = generate_password(default_length)
            pass_vault[sys.argv[1]] = password
            print(password)

    elif command == Command.GEN_LEN:  # pswm <alias> -g [length]

        if sys.argv[1] == "pswm":
            print("You cannot change or delete the master password.")   
        else:
            password = generate_password(sys.argv[3])
            pass_vault[sys.argv[1]] = password
            print(password)

    elif command == Command.DEL_KEY:  # pswm <alias> -d

        if sys.argv[1] == "pswm":
            print("You cannot change or delete the master password.")   
        else:
            del pass_vault[sys.argv[1]]

    elif command == Command.GET_KEY:  # pswm <alias>

        if sys.argv[1] not in pass_vault:
            print("No password for " + sys.argv[1] + " was found.")
        else:
            print(pass_vault[sys.argv[1]])

    elif command == Command.LST_KEY:  # pswm -a

        if len(pass_vault) == 0:
            print("The password vault is empty.")
        for alias in pass_vault:
            print(alias + ": " + pass_vault[alias])

    else:                            # pswm
        print(help_msg)

    lines = pass_vault_to_lines(pass_vault)
    lines_to_encrypted_file(lines, pass_vault_file, crypt_key)

    return


# Call the main function
if __name__ == "__main__":
    main()
